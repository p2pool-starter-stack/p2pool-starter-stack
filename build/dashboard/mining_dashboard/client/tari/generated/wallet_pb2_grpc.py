# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from . import network_pb2 as network__pb2
from . import types_pb2 as types__pb2
from . import wallet_pb2 as wallet__pb2

GRPC_GENERATED_VERSION = '1.78.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + ' but the generated code in wallet_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class WalletStub(object):
    """The gRPC interface for interacting with the wallet.
    Returns the current version of the running wallet service.

    This method retrieves the semantic version of the wallet software as defined in the Cargo.toml file (e.g., "1.2.3"). Useful for diagnostics and compatibility checks.

    Example usage (JavaScript gRPC client):
    ```javascript
    const response = await client.getVersion({});
    console.log(response.version); // e.g., "1.2.3"
    ```

    Example response:
    ```json
    {
    "version": "1.2.3"
    }
    ```
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetVersion = channel.unary_unary(
                '/tari.rpc.Wallet/GetVersion',
                request_serializer=wallet__pb2.GetVersionRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetVersionResponse.FromString,
                _registered_method=True)
        self.GetState = channel.unary_unary(
                '/tari.rpc.Wallet/GetState',
                request_serializer=wallet__pb2.GetStateRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetStateResponse.FromString,
                _registered_method=True)
        self.CheckConnectivity = channel.unary_unary(
                '/tari.rpc.Wallet/CheckConnectivity',
                request_serializer=wallet__pb2.GetConnectivityRequest.SerializeToString,
                response_deserializer=wallet__pb2.CheckConnectivityResponse.FromString,
                _registered_method=True)
        self.CheckForUpdates = channel.unary_unary(
                '/tari.rpc.Wallet/CheckForUpdates',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=network__pb2.SoftwareUpdate.FromString,
                _registered_method=True)
        self.Identify = channel.unary_unary(
                '/tari.rpc.Wallet/Identify',
                request_serializer=network__pb2.GetIdentityRequest.SerializeToString,
                response_deserializer=network__pb2.GetIdentityResponse.FromString,
                _registered_method=True)
        self.GetAddress = channel.unary_unary(
                '/tari.rpc.Wallet/GetAddress',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=wallet__pb2.GetAddressResponse.FromString,
                _registered_method=True)
        self.GetPaymentIdAddress = channel.unary_unary(
                '/tari.rpc.Wallet/GetPaymentIdAddress',
                request_serializer=wallet__pb2.GetPaymentIdAddressRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetCompleteAddressResponse.FromString,
                _registered_method=True)
        self.GetCompleteAddress = channel.unary_unary(
                '/tari.rpc.Wallet/GetCompleteAddress',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=wallet__pb2.GetCompleteAddressResponse.FromString,
                _registered_method=True)
        self.PrepareOneSidedTransactionForSigning = channel.unary_unary(
                '/tari.rpc.Wallet/PrepareOneSidedTransactionForSigning',
                request_serializer=wallet__pb2.PrepareOneSidedTransactionForSigningRequest.SerializeToString,
                response_deserializer=wallet__pb2.PrepareOneSidedTransactionForSigningResponse.FromString,
                _registered_method=True)
        self.PrepareDepositMultisigTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/PrepareDepositMultisigTransaction',
                request_serializer=wallet__pb2.PrepareDepositMultisigTransactionRequest.SerializeToString,
                response_deserializer=wallet__pb2.PrepareDepositMultisigTransactionResponse.FromString,
                _registered_method=True)
        self.PrepareWithdrawMultisigTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/PrepareWithdrawMultisigTransaction',
                request_serializer=wallet__pb2.PrepareWithdrawMultisigTransactionRequest.SerializeToString,
                response_deserializer=wallet__pb2.PrepareWithdrawMultisigTransactionResponse.FromString,
                _registered_method=True)
        self.BroadcastSignedOneSidedTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/BroadcastSignedOneSidedTransaction',
                request_serializer=wallet__pb2.BroadcastSignedOneSidedTransactionRequest.SerializeToString,
                response_deserializer=wallet__pb2.BroadcastSignedOneSidedTransactionResponse.FromString,
                _registered_method=True)
        self.Transfer = channel.unary_unary(
                '/tari.rpc.Wallet/Transfer',
                request_serializer=wallet__pb2.TransferRequest.SerializeToString,
                response_deserializer=wallet__pb2.TransferResponse.FromString,
                _registered_method=True)
        self.RangeLimitedCoinJoin = channel.unary_unary(
                '/tari.rpc.Wallet/RangeLimitedCoinJoin',
                request_serializer=wallet__pb2.RangeLimitedCoinJoinRequest.SerializeToString,
                response_deserializer=wallet__pb2.TransferResponse.FromString,
                _registered_method=True)
        self.GetTransactionInfo = channel.unary_unary(
                '/tari.rpc.Wallet/GetTransactionInfo',
                request_serializer=wallet__pb2.GetTransactionInfoRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetTransactionInfoResponse.FromString,
                _registered_method=True)
        self.GetCompletedTransactions = channel.unary_stream(
                '/tari.rpc.Wallet/GetCompletedTransactions',
                request_serializer=wallet__pb2.GetCompletedTransactionsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetCompletedTransactionsResponse.FromString,
                _registered_method=True)
        self.GetBlockHeightTransactions = channel.unary_unary(
                '/tari.rpc.Wallet/GetBlockHeightTransactions',
                request_serializer=wallet__pb2.GetBlockHeightTransactionsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetBlockHeightTransactionsResponse.FromString,
                _registered_method=True)
        self.GetTransactionPayRefs = channel.unary_unary(
                '/tari.rpc.Wallet/GetTransactionPayRefs',
                request_serializer=wallet__pb2.GetTransactionPayRefsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetTransactionPayRefsResponse.FromString,
                _registered_method=True)
        self.GetBalance = channel.unary_unary(
                '/tari.rpc.Wallet/GetBalance',
                request_serializer=wallet__pb2.GetBalanceRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetBalanceResponse.FromString,
                _registered_method=True)
        self.GetUnspentAmounts = channel.unary_unary(
                '/tari.rpc.Wallet/GetUnspentAmounts',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=wallet__pb2.GetUnspentAmountsResponse.FromString,
                _registered_method=True)
        self.CoinSplit = channel.unary_unary(
                '/tari.rpc.Wallet/CoinSplit',
                request_serializer=wallet__pb2.CoinSplitRequest.SerializeToString,
                response_deserializer=wallet__pb2.CoinSplitResponse.FromString,
                _registered_method=True)
        self.CoinHistogram = channel.unary_unary(
                '/tari.rpc.Wallet/CoinHistogram',
                request_serializer=wallet__pb2.CoinHistogramRequest.SerializeToString,
                response_deserializer=wallet__pb2.CoinHistogramResponse.FromString,
                _registered_method=True)
        self.ImportUtxos = channel.unary_unary(
                '/tari.rpc.Wallet/ImportUtxos',
                request_serializer=wallet__pb2.ImportUtxosRequest.SerializeToString,
                response_deserializer=wallet__pb2.ImportUtxosResponse.FromString,
                _registered_method=True)
        self.GetNetworkStatus = channel.unary_unary(
                '/tari.rpc.Wallet/GetNetworkStatus',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=network__pb2.NetworkStatusResponse.FromString,
                _registered_method=True)
        self.GetConnectedHttpPeer = channel.unary_unary(
                '/tari.rpc.Wallet/GetConnectedHttpPeer',
                request_serializer=types__pb2.Empty.SerializeToString,
                response_deserializer=wallet__pb2.GetConnectedHttpPeerResponse.FromString,
                _registered_method=True)
        self.CancelTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/CancelTransaction',
                request_serializer=wallet__pb2.CancelTransactionRequest.SerializeToString,
                response_deserializer=wallet__pb2.CancelTransactionResponse.FromString,
                _registered_method=True)
        self.RevalidateAllTransactions = channel.unary_unary(
                '/tari.rpc.Wallet/RevalidateAllTransactions',
                request_serializer=wallet__pb2.RevalidateRequest.SerializeToString,
                response_deserializer=wallet__pb2.RevalidateResponse.FromString,
                _registered_method=True)
        self.ValidateAllTransactions = channel.unary_unary(
                '/tari.rpc.Wallet/ValidateAllTransactions',
                request_serializer=wallet__pb2.ValidateRequest.SerializeToString,
                response_deserializer=wallet__pb2.ValidateResponse.FromString,
                _registered_method=True)
        self.SendShaAtomicSwapTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/SendShaAtomicSwapTransaction',
                request_serializer=wallet__pb2.SendShaAtomicSwapRequest.SerializeToString,
                response_deserializer=wallet__pb2.SendShaAtomicSwapResponse.FromString,
                _registered_method=True)
        self.CreateBurnTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/CreateBurnTransaction',
                request_serializer=wallet__pb2.CreateBurnTransactionRequest.SerializeToString,
                response_deserializer=wallet__pb2.CreateBurnTransactionResponse.FromString,
                _registered_method=True)
        self.ClaimShaAtomicSwapTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction',
                request_serializer=wallet__pb2.ClaimShaAtomicSwapRequest.SerializeToString,
                response_deserializer=wallet__pb2.ClaimShaAtomicSwapResponse.FromString,
                _registered_method=True)
        self.ClaimHtlcRefundTransaction = channel.unary_unary(
                '/tari.rpc.Wallet/ClaimHtlcRefundTransaction',
                request_serializer=wallet__pb2.ClaimHtlcRefundRequest.SerializeToString,
                response_deserializer=wallet__pb2.ClaimHtlcRefundResponse.FromString,
                _registered_method=True)
        self.CreateTemplateRegistration = channel.unary_unary(
                '/tari.rpc.Wallet/CreateTemplateRegistration',
                request_serializer=wallet__pb2.CreateTemplateRegistrationRequest.SerializeToString,
                response_deserializer=wallet__pb2.CreateTemplateRegistrationResponse.FromString,
                _registered_method=True)
        self.SignMessage = channel.unary_unary(
                '/tari.rpc.Wallet/SignMessage',
                request_serializer=wallet__pb2.SignMessageRequest.SerializeToString,
                response_deserializer=wallet__pb2.SignMessageResponse.FromString,
                _registered_method=True)
        self.StreamTransactionEvents = channel.unary_stream(
                '/tari.rpc.Wallet/StreamTransactionEvents',
                request_serializer=wallet__pb2.TransactionEventRequest.SerializeToString,
                response_deserializer=wallet__pb2.TransactionEventResponse.FromString,
                _registered_method=True)
        self.ImportTransactions = channel.unary_unary(
                '/tari.rpc.Wallet/ImportTransactions',
                request_serializer=wallet__pb2.ImportTransactionsRequest.SerializeToString,
                response_deserializer=wallet__pb2.ImportTransactionsResponse.FromString,
                _registered_method=True)
        self.GetAllCompletedTransactions = channel.unary_unary(
                '/tari.rpc.Wallet/GetAllCompletedTransactions',
                request_serializer=wallet__pb2.GetAllCompletedTransactionsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetAllCompletedTransactionsResponse.FromString,
                _registered_method=True)
        self.GetAllCompletedTransactionsStream = channel.unary_stream(
                '/tari.rpc.Wallet/GetAllCompletedTransactionsStream',
                request_serializer=wallet__pb2.GetAllCompletedTransactionsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetCompletedTransactionsResponse.FromString,
                _registered_method=True)
        self.GetPaymentByReference = channel.unary_unary(
                '/tari.rpc.Wallet/GetPaymentByReference',
                request_serializer=wallet__pb2.GetPaymentByReferenceRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetPaymentByReferenceResponse.FromString,
                _registered_method=True)
        self.GetFeeEstimate = channel.unary_unary(
                '/tari.rpc.Wallet/GetFeeEstimate',
                request_serializer=wallet__pb2.GetFeeEstimateRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetFeeEstimateResponse.FromString,
                _registered_method=True)
        self.GetFeePerGramStats = channel.unary_unary(
                '/tari.rpc.Wallet/GetFeePerGramStats',
                request_serializer=wallet__pb2.GetFeePerGramStatsRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetFeePerGramStatsResponse.FromString,
                _registered_method=True)
        self.ReplaceByFee = channel.unary_unary(
                '/tari.rpc.Wallet/ReplaceByFee',
                request_serializer=wallet__pb2.ReplaceByFeeRequest.SerializeToString,
                response_deserializer=wallet__pb2.ReplaceByFeeResponse.FromString,
                _registered_method=True)
        self.UserPayForFee = channel.unary_unary(
                '/tari.rpc.Wallet/UserPayForFee',
                request_serializer=wallet__pb2.UserPayForFeeRequest.SerializeToString,
                response_deserializer=wallet__pb2.UserPayForFeeResponse.FromString,
                _registered_method=True)
        self.RegisterValidatorNode = channel.unary_unary(
                '/tari.rpc.Wallet/RegisterValidatorNode',
                request_serializer=wallet__pb2.RegisterValidatorNodeRequest.SerializeToString,
                response_deserializer=wallet__pb2.RegisterValidatorNodeResponse.FromString,
                _registered_method=True)
        self.SubmitValidatorEvictionProof = channel.unary_unary(
                '/tari.rpc.Wallet/SubmitValidatorEvictionProof',
                request_serializer=wallet__pb2.SubmitValidatorEvictionProofRequest.SerializeToString,
                response_deserializer=wallet__pb2.SubmitValidatorEvictionProofResponse.FromString,
                _registered_method=True)
        self.SubmitValidatorNodeExit = channel.unary_unary(
                '/tari.rpc.Wallet/SubmitValidatorNodeExit',
                request_serializer=wallet__pb2.SubmitValidatorNodeExitRequest.SerializeToString,
                response_deserializer=wallet__pb2.SubmitValidatorNodeExitResponse.FromString,
                _registered_method=True)
        self.GetBurnClaimProof = channel.unary_unary(
                '/tari.rpc.Wallet/GetBurnClaimProof',
                request_serializer=wallet__pb2.GetBurnClaimProofRequest.SerializeToString,
                response_deserializer=wallet__pb2.GetBurnClaimProofResponse.FromString,
                _registered_method=True)
        self.RescanWallet = channel.unary_unary(
                '/tari.rpc.Wallet/RescanWallet',
                request_serializer=wallet__pb2.RescanWalletRequest.SerializeToString,
                response_deserializer=wallet__pb2.RescanWalletResponse.FromString,
                _registered_method=True)
        self.ScanAndImportUtxos = channel.unary_unary(
                '/tari.rpc.Wallet/ScanAndImportUtxos',
                request_serializer=wallet__pb2.ScanAndImportUtxosRequest.SerializeToString,
                response_deserializer=wallet__pb2.ScanAndImportUtxosResponse.FromString,
                _registered_method=True)


class WalletServicer(object):
    """The gRPC interface for interacting with the wallet.
    Returns the current version of the running wallet service.

    This method retrieves the semantic version of the wallet software as defined in the Cargo.toml file (e.g., "1.2.3"). Useful for diagnostics and compatibility checks.

    Example usage (JavaScript gRPC client):
    ```javascript
    const response = await client.getVersion({});
    console.log(response.version); // e.g., "1.2.3"
    ```

    Example response:
    ```json
    {
    "version": "1.2.3"
    }
    ```
    """

    def GetVersion(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetState(self, request, context):
        """Returns the current operational state of the wallet.

        This RPC provides an overview of the wallet's internal status, including:
        - The latest blockchain height scanned by the wallet
        - The current balance (available, pending incoming/outgoing)
        - Network connectivity status with the base node

        This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
        synchronized, and connected to the Tari network.

        Example usage (JavaScript):
        ```javascript
        const response = await client.getState({});
        console.log(response.scanned_height); // e.g., 1523493
        console.log(response.balance.available_balance); // e.g., 1234567890
        console.log(response.network.status); // e.g., "Online"
        ```

        Example response:
        ```json
        {
        "scanned_height": 1523493,
        "balance": {
        "available_balance": 1234567890,
        "pending_incoming_balance": 100000000,
        "pending_outgoing_balance": 0
        },
        "network": {
        "status": "Online",
        "avg_latency_ms": 28,
        "num_node_connections": 8
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CheckConnectivity(self, request, context):
        """This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.

        Example usage (JavaScript):
        ```javascript
        const response = await client.checkConnectivity({});
        console.log(response.status); // e.g., 1 (Online)
        ```

        Example response:
        ```json
        {
        "status": "Online"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CheckForUpdates(self, request, context):
        """Check for new updates
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Identify(self, request, context):
        """The `Identify` RPC call returns the identity information of the wallet node.
        This includes:
        - **Public Key**: The wallet's cryptographic public key.
        - **Public Address**: This will always be empty as the wallet has no contactable public comms address.
        - **Node ID**: The unique identifier of the wallet node in the network.

        Example usage (JavaScript):
        ```javascript
        // Call the Identify RPC method
        client.Identify({}, (error, response) => {
        if (error) {
        console.error('Error:', error);
        } else {
        console.log('Identity Response:', response);
        }
        });
        ```

        **Sample JSON Response:**

        ```json
        {
        "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
        "public_address": "",
        "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAddress(self, request, context):
        """This RPC returns two types of wallet addresses: interactive and one-sided addresses.
        It provides these addresses in byte format as part of the response.
        - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
        - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.

        Example usage (JavaScript):
        // Call the GetAddress RPC method
        client.GetAddress({}, (error, response) => {
        if (error) {
        console.error('Error:', error);
        } else {
        console.log('Address Response:', response);
        }
        });
        ```

        **Sample JSON Response:**
        // ```json
        {
        "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
        "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPaymentIdAddress(self, request, context):
        """This RPC returns addresses generated for a specific payment ID. It provides both the interactive
        and one-sided addresses for the given payment ID, along with their respective representations in
        base58 and emoji formats.

        Example usage (JavaScript):

        ```javascript
        // Prepare the payment ID for the request
        const paymentId = Buffer.from('your_payment_id_here', 'hex');
        const request = { payment_id: paymentId };

        // Call the GetPaymentIdAddress RPC method
        client.GetPaymentIdAddress(request, (error, response) => {
        if (error) {
        console.error('Error:', error);
        } else {
        console.log('Payment ID Address Response:', response);
        }
        });
        ```

        **Sample JSON Response:**

        ```json
        {
        "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
        "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
        "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
        "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
        "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
        "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
        }
        ```

        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetCompleteAddress(self, request, context):
        """This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
        The response includes:
        - Raw binary
        - Base58-encoded (human-readable)
        - Emoji-encoded (for fun and friendliness)

        Example usage (JavaScript with gRPC):

        ```js
        const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
        client.getCompleteAddress({}, (err, response) => {
        if (err) console.error(err);
        else console.log(response);
        });
        ```

        Sample response:
        ```json
        {
        "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
        "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
        "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
        "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
        "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
        "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PrepareOneSidedTransactionForSigning(self, request, context):
        """Prepares a one-sided transaction for offline signing.

        The PrepareOneSidedTransactionForSigning RPC prepares the structure of a one-sided transaction that can be signed
        offline. It returns the transaction data in JSON format, which can be signed externally and later submitted.
        This is useful for air-gapped workflows, hardware wallet integrations, and secure transaction creation.

        ### Request Parameters:

        - `recipient` (required):
        - **Type**: `PaymentRecipient`
        - **Description**: Contains details of the intended recipient, including address, amount, fee, and optional
        payment identifiers.
        - **Required Fields**:
        - `address`:  
        - **Type**: `string`  
        - **Description**: A valid Tari address of the recipient.  
        - **Validation**: Must be a well-formed TariAddress; malformed addresses will result in an error.
        - `amount`:  
        - **Type**: `uint64`  
        - **Description**: Amount to send in MicroTari (ÂµT).  
        - **Validation**: Must be greater than zero.
        - `fee_per_gram`:  
        - **Type**: `uint64`  
        - **Description**: Fee rate in ÂµT per gram of transaction weight.  
        - **Validation**: Must be set to a reasonable network value.
        - `payment_type`:
        - **Type**: `enum PaymentType`
        - **Description**: Defines the transaction style.
        - **Options**:
        - `STANDARD_MIMBLEWIMBLE = 0` *(deprecated)*
        - `ONE_SIDED = 1` *(deprecated)*
        - `ONE_SIDED_TO_STEALTH_ADDRESS = 2` *(recommended)*
        - **Optional Fields**:
        - `raw_payment_id`:  
        - **Type**: `bytes`  
        - **Description**: Custom payment identifier in raw byte format.
        - `user_payment_id`:  
        - **Type**: `UserPaymentId`  
        - **Description**: Flexible payment ID that can be one of the following:
        - `u256`: Hex string representing a 256-bit ID
        - `utf8_string`: A human-readable string
        - `user_bytes`: Custom byte sequence
        - **Restrictions**: Exactly one field must be populated. If multiple or none are provided, the request will fail.

        ### Response Fields:

        - `is_success`:
        - **Type**: `bool`
        - **Description**: Indicates whether the transaction preparation succeeded.

        - `result`:
        - **Type**: `string`
        - **Description**: A JSON-encoded string of the unsigned transaction data. Only populated if `is_success` is `true`.

        - `failure_message`:
        - **Type**: `string`
        - **Description**: A message describing why the preparation failed. Only populated if `is_success` is `false`.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        recipient: {
        address: "tari:4dQ3b...",
        amount: 1000000,
        fee_per_gram: 25,
        user_payment_id: { utf8_string: "Invoice #1234" }
        }
        };
        client.prepareOneSidedTransactionForSigning(request, (err, response) => {
        if (err) console.error("RPC Error:", err);
        else if (!response.is_success) console.error("Preparation failed:", response.failure_message);
        else console.log("Prepared transaction:", response.result);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "is_success": true,
        "result": "{ \"amount\": 1000000, \"fee\": 25, \"recipient\": \"tari:4dQ3b...\", \"inputs\": [...], \"outputs\": [...] }",
        "failure_message": ""
        }
        ```

        If preparation fails:

        ```json
        {
        "is_success": false,
        "result": "",
        "failure_message": "Destination address is malformed."
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PrepareDepositMultisigTransaction(self, request, context):
        """Prepares a multisignature deposit transaction for offline signing.

        The PrepareDepositMultisigTransaction RPC constructs a deposit transaction requiring multiple signers,
        which can be signed and completed offline. This is commonly used to fund shared wallets or validator nodes
        that rely on multisignature output scripts.

        The transaction is returned in JSON format and can be signed by each participant independently.

        ### Request Parameters:

        - `amount` (required):
        - **Type**: `uint64`
        - **Description**: The amount to deposit in MicroTari (ÂµT).
        - **Validation**: Must be greater than 0.

        - `party_number` (required):
        - **Type**: `uint64`
        - **Description**: The index of the current signer (this party) in the multisignature group.
        - **Validation**:
        - Must be greater than 0.
        - Must be less than or equal to the number of provided public keys.
        - Will be cast to an unsigned 8-bit integer (`u8`).

        - `public_keys` (required):
        - **Type**: `repeated bytes`
        - **Description**: A list of canonical public keys (compressed) representing all participants in the multisig group.
        - **Validation**:
        - Must include at least one key.
        - All public keys must be valid and unique.
        - Public key at `party_number - 1` is assumed to be the current caller.

        - `recipient_address` (required):
        - **Type**: `bytes`
        - **Description**: A byte-encoded Tari address to which the deposit output will be attributed.
        - **Validation**: Must be a valid `TariAddress`; invalid values will trigger an error.

        ### Response Fields:

        - `is_success`:
        - **Type**: `bool`
        - **Description**: Indicates whether the deposit transaction was prepared successfully.

        - `result`:
        - **Type**: `string`
        - **Description**: A JSON-encoded representation of the unsigned multisig transaction. Present only if `is_success` is `true`.

        - `failure_message`:
        - **Type**: `string`
        - **Description**: Explains why the transaction preparation failed. Present only if `is_success` is `false`.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        amount: 5000000,
        party_number: 1,
        public_keys: [
        Buffer.from("03a1...abc", "hex"),
        Buffer.from("02bc...def", "hex")
        ],
        recipient_address: Buffer.from("a1b2...c3d4", "hex")
        };

        client.prepareDepositMultisigTransaction(request, (err, response) => {
        if (err) {
        console.error("RPC error:", err);
        } else if (!response.is_success) {
        console.error("Preparation failed:", response.failure_message);
        } else {
        console.log("Multisig transaction:", response.result);
        }
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "is_success": true,
        "result": "{ \"amount\": 5000000, \"public_keys\": [\"...\"], \"recipient\": \"tari:...\", \"outputs\": [...] }",
        "failure_message": ""
        }
        ```

        If preparation fails:

        ```json
        {
        "is_success": false,
        "result": "",
        "failure_message": "public_keys must be unique"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PrepareWithdrawMultisigTransaction(self, request, context):
        """Prepares a multisignature withdrawal transaction for offline signing.

        The PrepareWithdrawMultisigTransaction RPC constructs a transaction that spends a previously created multisig UTXO.
        The caller must supply a valid UTXO commitment and a complete set of Schnorr signatures from all multisig participants.
        The unsigned transaction is returned as JSON and can be submitted once fully signed.

        ### Request Parameters:

        - `utxo_commitment` (required):
        - **Type**: `string`
        - **Description**: A hex-encoded commitment of the multisig UTXO to be spent.
        - **Validation**: Must be a valid commitment string (compressed format).

        - `signatures` (required):
        - **Type**: `repeated bytes`
        - **Description**: A list of raw signature byte arrays used in the multisig withdrawal.
        Each item may represent a full or partial signature, or a concatenated sequence of signature fragments.
        The interpretation depends on the signing scheme used by the multisig script.

        - `recipient_address` (required):
        - **Type**: `bytes`
        - **Description**: A byte-encoded Tari address to receive the withdrawn funds.
        - **Validation**: Must be a valid `TariAddress`; invalid values will cause the request to fail.

        ### Response Fields:

        - `is_success`:
        - **Type**: `bool`
        - **Description**: Indicates whether the transaction was successfully prepared.

        - `result`:
        - **Type**: `string`
        - **Description**: A JSON-encoded string of the unsigned withdrawal transaction. Only present if `is_success` is `true`.

        - `failure_message`:
        - **Type**: `string`
        - **Description**: Describes the reason for failure. Only present if `is_success` is `false`.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        utxo_commitment: "b2f3e1...9ac4",
        signatures: [
        Buffer.from("3045...f1a2", "hex"),
        Buffer.from("3081...9b23", "hex")
        ],
        recipient_address: Buffer.from("a1b2...c3d4", "hex")
        };

        client.prepareWithdrawMultisigTransaction(request, (err, response) => {
        if (err) {
        console.error("RPC error:", err);
        } else if (!response.is_success) {
        console.error("Preparation failed:", response.failure_message);
        } else {
        console.log("Withdrawal transaction:", response.result);
        }
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "is_success": true,
        "result": "{ \"inputs\": [\"b2f3e1...\"], \"outputs\": [...], \"recipient\": \"tari:...\" }",
        "failure_message": ""
        }
        ```

        If preparation fails:

        ```json
        {
        "is_success": false,
        "result": "",
        "failure_message": "Invalid UTXO commitment hash: invalid hex format"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def BroadcastSignedOneSidedTransaction(self, request, context):
        """Broadcasts a signed one-sided transaction to the Tari network.

        The BroadcastSignedOneSidedTransaction RPC takes a fully signed one-sided transaction prepared offline
        and broadcasts it to the network for inclusion in the blockchain.
        The transaction must be a valid JSON string representation of a SignedOneSidedTransactionResult.

        ### Request Parameters:

        - `request` (required):
        - **Type**: `string`
        - **Description**: A JSON-encoded string representing a fully signed one-sided transaction.
        - **Validation**:
        - Must be a valid JSON string conforming to the expected format.
        - The transaction must be complete and correctly signed.

        ### Response Fields:

        - `is_success`:
        - **Type**: `bool`
        - **Description**: Indicates whether the transaction was successfully broadcast to the network.

        - `transaction_id`:
        - **Type**: `uint64`
        - **Description**: The internal transaction ID assigned by the wallet.
        - Only present if `is_success` is `true`.

        - `failure_message`:
        - **Type**: `string`
        - **Description**: Provides context for any broadcast failure. Present only if `is_success` is `false`.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        request: JSON.stringify({
        amount: "1000000",
        fee: "25",
        recipient: "tari:...",
        ... // full signed transaction structure
        })
        };

        client.broadcastSignedOneSidedTransaction(request, (err, response) => {
        if (err) {
        console.error("Broadcast error:", err);
        } else if (!response.is_success) {
        console.error("Broadcast failed:", response.failure_message);
        } else {
        console.log("Transaction ID:", response.transaction_id);
        }
        });
        ```

        ### Sample JSON Response (Success):

        ```json
        {
        "is_success": true,
        "transaction_id": 1054321,
        "failure_message": ""
        }
        ```

        ### Sample JSON Response (Failure):

        ```json
        {
        "is_success": false,
        "transaction_id": 0,
        "failure_message": "Transaction signature is invalid"
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Transfer(self, request, context):
        """This call supports standard interactive transactions (Mimblewimble),
        one-sided transactions, and one-sided-to-stealth-address transactions.
        Each recipient must include a valid Tari address, amount, fee, and payment type.
        SingleTx is used to indicate should this be sent as a single MW tx or multiple, one tx per recipient.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const recipient = new PaymentRecipient();
        recipient.setAddress("14HVCEeZ...");
        recipient.setAmount(1000000); // 1 T
        recipient.setFeePerGram(25);
        recipient.setPaymentType(PaymentType.ONE_SIDED);
        recipient.setPaymentId(Buffer.from("abc123", "utf-8"));

        const request = new TransferRequest();
        request.setRecipientsList([recipient]);
        request.setSingleTx(false);

        client.transfer(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response.toObject());
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "results": [
        {
        "address": "14HVCEeZ...",
        "transaction_id": 12345,
        "is_success": true,
        "failure_message": ""
        }
        ]
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RangeLimitedCoinJoin(self, request, context):
        """This call creates a CoinJoin transaction spending the output(s) to the owner wallet, ensuring that the inputs
        (currently unspent outputs) falls within a specified range and that the minimum coin-joined target amount is met.
        If the specified range does not allow for sufficient inputs to meet the target amount, the transaction will not be
        created. The process will continue until all unspent outputs in the specified range has been evaluated and used in
        coin-join transactions. As an example, if the wallet has 10_000 inputs in a specified range, and the maximum inputs
        per coin-join transaction is set to 1_000, then a minimum of 10 coin-join transactions will be created to cover all
        inputs in the range, where the maximum will be determined by the individual input values and the target coin-joined
        value. Either total fee or fee per gram can be specified, with preference given to the latter if both are
        specified.

        ### Request Parameters:
        - `maximum_inputs_per_transaction` (required):
        - **Type**: `uint32`
        - **Description**: The maximum number of inputs to include in each coin-join transaction.
        - **Restrictions**:
        - Must be greater than 0.
        - `target_minimum_amount` (required):
        - **Type**: `uint64`
        - **Description**: The minimum total amount to be coin-joined in each transaction (in MicroTari).
        - **Restrictions**:
        - Must be greater than 0.
        - Must be greater than `upper_bound`
        - `lower_bound` (required):
        - **Type**: `uint64`
        - **Description**: The inclusive lower bound of the input value range (in MicroTari).
        - **Restrictions**:
        - Must be less than `upper_bound`.
        - `upper_bound` (required):
        - **Type**: `uint64`
        - **Description**: The exclusive upper bound of the input value range (in MicroTari).
        - **Restrictions**:
        - Must be greater than `lower_bound`.
        - `total_fee` (optional):
        - **Type**: `uint64`
        - **Description**: The total fee to be paid for each coin-join transaction (in MicroTari).
        - **Restrictions**:
        - If specified, must be greater than 0.
        - `fee_per_gram` (optional):
        - **Type**: `uint64`
        - **Description**: The fee per gram to be paid for each coin-join transaction (in MicroTari).
        - **Restrictions**:
        - If specified, must be greater than 0.
        - `user_payment_id`:
        - **Type**: `UserPaymentId`
        - **Description**: Flexible payment ID that can be one of the following:
        - `u256`: Hex string representing a 256-bit ID
        - `utf8_string`: A human-readable string
        - `user_bytes`: Custom byte sequence
        - **Restrictions**: Exactly one field must be populated. If multiple or none are provided, the request will fail.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = new RangeLimitedCoinJoinRequest();
        request.setMaximumInputsPerTransaction(1000);
        request.setTargetAmount(100000000);  // 100 T
        request.setLowerBound(0);            // 0 T (inclusive)
        request.setUpperBound(100000);       // 0.1 T (exclusive)
        request.setTotalFee(100);            // 0.0001 T
        request.setFeePerGram(1);            // 0.000001 T
        request.setUserPaymentId("For you");

        client.rangeLimitCoinJoin(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response.toObject());
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "results": [
        {
        "address": "14HVCEeZ...",
        "transaction_id": 12345,
        "is_success": true,
        "failure_message": ""
        }
        ]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetTransactionInfo(self, request, context):
        """Returns the transaction details for the given transaction IDs.

        The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
        The response includes details such as transaction status, direction, amount, fee, and more.

        ### Request Parameters:

        - `transaction_ids` (required):
        - **Type**: `repeated uint64`
        - **Description**: A list of transaction IDs to query.
        - **Restrictions**:
        - Must contain at least one ID.
        - All IDs must be valid unsigned 64-bit integers.
        - Duplicates will be ignored; only the first occurrence is processed.
        - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = { transaction_ids: [12345, 67890] };
        client.getTransactionInfo(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response.transactions);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "transactions": [
        {
        "tx_id": 12345,
        "source_address": "0x1234abcd...",
        "dest_address": "0x5678efgh...",
        "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        "direction": "TRANSACTION_DIRECTION_OUTBOUND",
        "amount": 1000000,
        "fee": 25,
        "is_cancelled": false,
        "excess_sig": "0xabcdef...",
        "timestamp": 1681234567,
        "payment_id": "0xdeadbeef...",
        "mined_in_block_height": 1523493
        }
        ]
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetCompletedTransactions(self, request, context):
        """Streams completed transactions for a given user payment ID.

        The `GetCompletedTransactions` call retrieves all completed wallet transactions,
        optionally filtered by a specific `payment_id` and/or block hash. The response is streamed back to the client
        one transaction at a time, with each transaction including details such as status, direction,
        amount, fees, and associated metadata.

        ### Request Parameters:

        - `payment_id` (optional):
        - **Type**: `UserPaymentId` (a flexible ID object)
        - **Description**: Allows filtering the completed transactions by a specific payment ID.
        - **Accepted Formats** (must provide **only one**):
        - `u256`: a 32-byte hexadecimal string.
        - `utf8_string`: a UTF-8 string.
        - `user_bytes`: raw bytes.
        - **Restrictions**:
        - Exactly **one format must be set**. Providing more than one or none results in an error.
        - If no `payment_id` is provided, all completed transactions will be returned.

        - `block_hash` (optional):
        - **Type**: `string`
        - **Description**: A specific block hash to filter transactions by.
        - **Accepted Formats**
        - Hexadecimal string representing the block hash.
        - **Restrictions**:
        - If provided, the transactions will be filtered to only those included in the specified block.

        - `block_height` (optional):
        - **Type**: `uint64`
        - **Description**: A specific block height to filter transactions by.
        - **Restrictions**:
        - If provided, the transactions will be filtered to only those included in the specified height.


        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        payment_id: {
        utf8_string: "invoice-001"
        }
        };
        const call = client.getCompletedTransactions(request);
        call.on('data', (response) => {
        console.log(response.transaction);
        });
        call.on('error', console.error);
        call.on('end', () => console.log("Stream ended"));
        ```

        ### Sample Streamed JSON Response:

        ```json
        {
        "transaction": {
        "tx_id": 12345,
        "source_address": "0x1234abcd...",
        "dest_address": "0x5678efgh...",
        "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        "direction": "TRANSACTION_DIRECTION_INBOUND",
        "amount": 500000,
        "fee": 20,
        "is_cancelled": false,
        "excess_sig": "0xabcdef...",
        "timestamp": 1681234567,
        "payment_id": "0xdeadbeef...",
        "mined_in_block_height": 1523493
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetBlockHeightTransactions(self, request, context):
        """Returns all transactions that were mined at a specific block height.

        The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
        at the specified block height. The response includes all transactions in a single response,
        with each transaction including details such as status, direction, amount,
        fees, and associated metadata.

        ### Request Parameters:

        - `block_height` (required):
        - **Type**: `uint64`
        - **Description**: The specific block height to fetch transactions for.
        - **Restrictions**:
        - Must be a valid block height (greater than 0).
        - If the block height is beyond the current chain height, no transactions will be returned.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        block_height: 1523493
        };
        const response = await client.getBlockHeightTransactions(request);
        console.log(response.transactions);
        ```

        ### Sample JSON Response:

        ```json
        {
        "transactions": [
        {
        "tx_id": 12345,
        "source_address": "0x1234abcd...",
        "dest_address": "0x5678efgh...",
        "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        "direction": "TRANSACTION_DIRECTION_INBOUND",
        "amount": 500000,
        "fee": 20,
        "is_cancelled": false,
        "excess_sig": "0xabcdef...",
        "timestamp": 1681234567,
        "payment_id": "0xdeadbeef...",
        "mined_in_block_height": 1523493
        }
        ]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetTransactionPayRefs(self, request, context):
        """Returns all PayRefs (payment references) for a specific transaction.

        The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
        transaction ID. PayRefs are cryptographic references generated from output hashes
        that allow recipients to verify payments without revealing sensitive transaction details.

        ### Request Parameters:

        - `transaction_id` (required):
        - **Type**: `uint64`
        - **Description**: The transaction ID to retrieve PayRefs for.
        - **Restrictions**:
        - Must be a valid transaction ID that exists in the wallet.
        - If the transaction ID is invalid or not found, an error will be returned.

        ### Response:
        - **payment_references** (repeated bytes): Metadata references associated with change outputs. *(deprecated)*
        - **output_commitments_info** (repeated CommitmentInfo):
        Contains details for each output commitment in the transaction.
        Each CommitmentInfo includes:
        - `hash` (bytes): The hash representing the output.
        - `commitment` (bytes): The cryptographic commitment representing the output.
        - `payment_reference` (bytes): The associated payment reference for the output.
        - `category` (enum): The category of the output (`Sent`, `Received`, `Change`).

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        transaction_id: 12345
        };
        const response = await client.getTransactionPayRefs(request);
        console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
        ```

        ### Sample JSON Response:

        ```json
        {
        "payment_references": [
        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
        "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
        ]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetBalance(self, request, context):
        """Returns the wallet balance details.

        The `GetBalance` call retrieves the current balance status of the wallet,
        optionally filtered by a specific `payment_id`. The response includes detailed
        breakdowns of available, pending incoming/outgoing, and timelocked balances.

        ### Request Parameters:

        - `payment_id` (optional):
        - **Type**: `UserPaymentId` (one of several formats).
        - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
        - **Accepted Formats** (must provide **only one**):
        - `u256`: a 32-byte hexadecimal identifier.
        - `utf8_string`: a human-readable string ID.
        - `user_bytes`: raw binary bytes.
        - **Restrictions**:
        - Only one format must be provided at a time.
        - If multiple or no formats are provided within `payment_id`, the request will return an error.
        - If `payment_id` is omitted, the total wallet balance is returned.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        payment_id: {
        utf8_string: "invoice-002"
        }
        };
        client.getBalance(request, (err, response) => {
        if (err) console.error(err);
        else console.log("Balance:", response);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "available_balance": 950000,
        "pending_incoming_balance": 200000,
        "pending_outgoing_balance": 50000,
        "timelocked_balance": 100000
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetUnspentAmounts(self, request, context):
        """Returns the total value of unspent outputs in the wallet.

        The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
        currently held by the wallet. These are outputs that have not yet been spent or time-locked,
        and are available for future transactions.

        ### Request Parameters:

        - *(none)*
        - This method uses an empty request body (`google.protobuf.Empty`).
        - No filters or arguments are required.

        ### Example JavaScript gRPC client usage:

        ```javascript
        client.getUnspentAmounts({}, (err, response) => {
        if (err) console.error(err);
        else console.log("Total unspent amount:", response.amount);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "amount": 1250000
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CoinSplit(self, request, context):
        """Creates a transaction that splits funds into multiple smaller outputs.

        The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
        This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
        The resulting transaction is broadcast and can be tracked via its transaction ID.

        ### Request Parameters:

        - `amount_per_split` (required):
        - **Type**: `uint64`
        - **Description**: The value of each individual output in the split.
        - **Restrictions**: Must be greater than zero.

        - `split_count` (required):
        - **Type**: `uint64`
        - **Description**: The number of outputs to create.
        - **Restrictions**: Must be greater than zero and within practical system limits.

        - `fee_per_gram` (required):
        - **Type**: `uint64`
        - **Description**: The transaction fee rate (per gram of weight).
        - **Restrictions**: Should be set high enough to ensure confirmation.

        - `lock_height` (optional):
        - **Type**: `uint64`
        - **Description**: The earliest block height at which the transaction becomes valid.
        - **Restrictions**: Defaults to 0 if not specified.

        - `payment_id` (optional):
        - **Type**: `bytes`
        - **Description**: A user-defined identifier for tracking or referencing the transaction.
        - **Restrictions**: Optional; can be left empty.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        amount_per_split: 100000,
        split_count: 5,
        fee_per_gram: 25,
        lock_height: 0,
        payment_id: new Uint8Array([])
        };
        client.coinSplit(request, (err, response) => {
        if (err) console.error(err);
        else console.log("Created CoinSplit Tx ID:", response.tx_id);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "tx_id": 987654321
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CoinHistogram(self, request, context):
        """Creates a histogram of coin (UTXO) sizes in the wallet.

        The `CoinHistogram` call generates a histogram representing the distribution of unspent transaction outputs (UTXOs)
        in the wallet. The histogram groups UTXOs into bins/buckets based on their amounts, allowing users to analyze the
        composition of their wallet's funds. Lower bounds are inclusive, while upper bound are exclusive.

        ### Request Parameters:
        - `lower_bound` (required):
        - **Type**: `uint64`
        - **Description**: The inclusive lower bound of the input value range (in MicroTari).
        - **Restrictions**:
        - Must be less than `upper_bound`.
        - `upper_bound` (required):
        - **Type**: `uint64`
        - **Description**: The exclusive upper bound of the input value range (in MicroTari).
        - **Restrictions**:
        - Must be greater than `lower_bound`.

        - None
        - This method uses an empty request body (CoinHistogramRequest).

        ### Example JavaScript gRPC client usage:

        ```javascript
        client.coinHistogram({}, (err, response) => {
        if (err) console.error(err);
        else console.log("Coin Histogram:", response.buckets);
        });
        ```
        ### Sample JSON Response:

        ```json
        {
        "buckets": [
        { "count": 212, "total_amount": 1234,         "lower_bound": 0,          "upper_bound": 10000 },
        { "count": 5,   "total_amount": 56789,        "lower_bound": 10000,      "upper_bound": 100000 },
        { "count": 0,   "total_amount": 0,            "lower_bound": 100000,     "upper_bound": 1000000 },
        { "count": 0,   "total_amount": 0,            "lower_bound": 1000000,    "upper_bound": 1000000000 },
        { "count": 1,   "total_amount": 111222333000, "lower_bound": 1000000000, "upper_bound": 1000000000000 }
        ]
        }
        ```

        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ImportUtxos(self, request, context):
        """Imports UTXOs into the wallet as spendable outputs.

        The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
        into the wallet, marking them as spendable without needing rewindable metadata.
        Each UTXO is associated with a transaction ID in the response.

        ### Request Parameters:

        - `outputs` (required):
        - **Type**: `repeated UnblindedOutput`
        - **Description**: A list of unblinded outputs to import into the wallet.
        - **Restrictions**:
        - Each output must be valid and convertible to an internal UTXO format.
        - The list must contain at least one item.

        - `payment_id` (optional):
        - **Type**: `bytes`
        - **Description**: An optional user-defined identifier to associate with the imported outputs.
        - **Restrictions**:
        - Can be left empty if not needed.
        - Must be a valid byte string if provided.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        outputs: [/* array of unblinded outputs */],
        payment_id: new Uint8Array([])
        };
        client.importUtxos(request, (err, response) => {
        if (err) console.error(err);
        else console.log("Imported Tx IDs:", response.tx_ids);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "tx_ids": [101, 102, 103]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetNetworkStatus(self, request, context):
        """Returns the wallet's current network connectivity status.

        The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
        including whether it is online, the number of active peer connections, and the average latency
        to the configured base node.

        ### Request Parameters:

        - *(none)*
        - This method uses an empty request body (`google.protobuf.Empty`).
        - No filters or arguments are required.

        ### Example JavaScript gRPC client usage:

        ```javascript
        client.getNetworkStatus({}, (err, response) => {
        if (err) console.error(err);
        else console.log("Network Status:", response);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "status": "ONLINE",
        "avg_latency_ms": 142,
        "num_node_connections": 1
        }
        ```

        ### Status Field Values:

        The `status` field indicates the current network connectivity of the wallet. Possible values are:

        - `INITIALIZING`:
        - The wallet connectivity is busy initializing.

        - `ONLINE`:
        - The wallet is fully connected to the network and functioning normally.

        - `DEGRADED`:
        - The wallet is connected but has high latency.
        - This could indicate issues with network connectivity, such as as a congested network, leading to reduced
        performance or reliability.

        - `OFFLINE`:
        - The wallet is not connected to any peers.
        - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.

        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetConnectedHttpPeer(self, request, context):
        """Returns a list of HTTP peers currently connected to the wallet.

        The `GetConnectedHttpPeer` call retrieves information about the HTTP peer that the wallet is currently
        connected to. The response is a `GetConnectedHttpPeerResponse` containing a list of `HttpPeer` objects.

        ### Request Parameters:

        - *(none)*
        - This method uses an empty request body (`google.protobuf.Empty`).
        - No filters or arguments are required.

        ### Response Fields:

        - **connected_peers**: List of `HttpPeer` objects currently connected to the wallet.
        - **url**: The connection URL (string).
        - **last_latency**: The latency of the last request to this peer (`AverageLatency`).
        - **is_online**: Online status of the peer (bool).

        ### Example JavaScript gRPC client usage:

        ```javascript
        client.GetConnectedHttpPeer({}, (err, response) => {
        if (err) console.error(err);
        else console.log("Connected Peers:", response);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "connected_peers": {
        "url": "http://127.0.0.1:18080",
        "last_latency": { "value": 42 },
        "is_online": true
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CancelTransaction(self, request, context):
        """Cancels a specific transaction by its ID.

        The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
        If the cancellation is successful, the response will indicate success. Otherwise, the response will
        contain a failure message with the reason for the failure.

        ### Request Parameters:

        - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
        - **force_if_completed**: Force cancelling a completed transaction, otherwise it is only applicable to pending
        transactions (bool).

        ### Response Fields:

        - **is_success**: A boolean indicating whether the cancellation was successful (bool).
        - `true` if the cancellation was successful, `false` if not.
        - **failure_message**: A string that provides the reason for the failure, if applicable (string).
        - This field will be empty if the cancellation was successful.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = { tx_id: 12345 };
        client.cancelTransaction(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "is_success": true,
        "failure_message": ""
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RevalidateAllTransactions(self, request, context):
        """Will trigger a complete revalidation of all wallet outputs.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ValidateAllTransactions(self, request, context):
        """Will trigger a validation of all wallet outputs.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SendShaAtomicSwapTransaction(self, request, context):
        """Sends a XTR SHA Atomic Swap transaction.

        The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
        transaction using SHA. It allows the sender to send a payment to the recipient
        in exchange for an atomic swap, with SHA used as the secret for the swap.
        The method accepts the recipient's information and initiates the transaction.

        ### Request Parameters:
        - **recipient** (required): A PaymentRecipient object containing the recipient's address,
        the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.

        ### Response Fields:
        - **transaction_id**: The ID of the transaction.
        - **pre_image**: The SHA pre-image of the atomic swap.
        - **output_hash**: The hash of the output associated with the transaction.
        - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
        - **failure_message**: Provides an error message if the transaction failed.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        recipient: {
        address: "t1abc12345",
        amount: 1000000,
        fee_per_gram: 10,
        payment_id: "0xdeadbeef"
        }
        };
        client.sendShaAtomicSwapTransaction(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "transaction_id": 123456789,
        "pre_image": "0xabcdef1234567890",
        "output_hash": "0x123456abcdef7890",
        "is_success": true,
        "failure_message": ""
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CreateBurnTransaction(self, request, context):
        """Creates a burn transaction for burning a specified amount of Tari currency.

        The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
        by initiating a burn transaction. It allows the user to specify the amount to burn,
        along with a fee per gram and optionally a payment ID and claim public key.

        ### Request Parameters:
        - **amount** (required): The amount of Tari to be burned.
        - **fee_per_gram** (required): The fee per gram for the transaction.
        - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
        - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.

        ### Response Fields:
        - **transaction_id**: The ID of the burn transaction.
        - **is_success**: Indicates whether the burn transaction was successfully created.
        - **failure_message**: Provides an error message if the transaction creation failed.
        - **commitment**: The commitment associated with the burn transaction.
        - **ownership_proof**: A proof of ownership for the burned coins.
        - **range_proof**: The range proof associated with the burned coins.
        - **claim_public_key**: The public key used for the burn claim.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        amount: 1000000,
        fee_per_gram: 10,
        claim_public_key: "0xabcdef1234567890",
        payment_id: "0xdeadbeef"
        };
        client.createBurnTransaction(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "transaction_id": 123456789,
        "is_success": true,
        "failure_message": "",
        "commitment": "0xcommitmenthash",
        "ownership_proof": "0xownershipproof",
        "claim_public_key": "0xclaimpublickey"
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ClaimShaAtomicSwapTransaction(self, request, context):
        """Claims a SHA Atomic Swap transaction using a pre-image and output hash.

        The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
        a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
        previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
        secret required to spend the output.

        ### Request Parameters:
        - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
        - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
        - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.

        ### Input Validation:
        - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
        - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
        - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.

        ### Response Fields:
        - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
        pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
        fee_per_gram: 10
        };
        client.claimShaAtomicSwapTransaction(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response.results);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "results": {
        "address": "",
        "transaction_id": 789654,
        "is_success": true,
        "failure_message": ""
        }
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ClaimHtlcRefundTransaction(self, request, context):
        """Claims an HTLC refund transaction after the timelock period has passed.

        The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
        to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
        This is possible only after the output's timelock has expired.

        ### Request Parameters:
        - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
        - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.

        ### Input Validation:
        - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
        - `fee_per_gram` must be a non-zero `uint64` value.

        ### Response Fields:
        - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        output_hash: "aabbccddeeff0011...99",
        fee_per_gram: 20
        };
        client.claimHtlcRefundTransaction(request, (err, response) => {
        if (err) console.error(err);
        else console.log(response.results);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "results": {
        "address": "",
        "transaction_id": 889977,
        "is_success": true,
        "failure_message": ""
        }
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CreateTemplateRegistration(self, request, context):
        """Creates a transaction with a template registration output
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SignMessage(self, request, context):
        """Signs a message using the wallet's node identity private key.

        The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
        This signature can be used to prove ownership of the wallet or authenticate messages.
        The signature is returned as separate components (signature and public nonce) for verification.

        ### Request Parameters:

        - `message` (required):
        - **Type**: `bytes`
        - **Description**: The message to be signed (arbitrary bytes).
        - **Restrictions**: Can be any byte sequence.

        ### Response Fields:

        - **signature**: The Schnorr signature as hex-encoded bytes.
        - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.

        ### Example JavaScript gRPC client usage:

        ```javascript
        const request = {
        message: Buffer.from("Hello Tari!", "utf-8")
        };
        client.signMessage(request, (err, response) => {
        if (err) console.error(err);
        else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "signature": "a1b2c3d4e5f6...",
        "public_nonce": "f6e5d4c3b2a1..."
        }
        ```

        ### Security Notes:

        - This signs with the wallet's node identity private key.
        - The signature can be verified using the wallet's public key.
        - Use this for authentication and ownership proofs only.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamTransactionEvents(self, request, context):
        """Streams real-time wallet transaction events to the client.

        The `StreamTransactionEvents` RPC provides a continuous stream of transaction events as they occur within the wallet.
        This allows clients to react to changes in transaction status such as received, sent, mined, or cancelled transactions,
        making it ideal for real-time UI updates or external monitoring.

        ### Request Parameters:
        - _(none)_ â€“ This RPC does not take any parameters.

        ### Response Stream:
        - Each message in the response stream is a `TransactionEventResponse` containing:
        - **transaction**: A `TransactionEvent` object representing the latest event related to a wallet transaction.

        ### `TransactionEvent` Fields:
        - **event** (string): Human-readable event type. Examples include: `"Received"`, `"Mined"`, `"Cancelled"`, `"Sent"`.
        - **tx_id** (string): Transaction identifier.
        - **source_address** (bytes): Sender address, if applicable.
        - **dest_address** (bytes): Recipient address, if applicable.
        - **status** (string): Current status of the transaction. E.g., `"Completed"`, `"Pending"`, `"Cancelled"`.
        - **direction** (string): `"Inbound"` or `"Outbound"`.
        - **amount** (uint64): Transaction amount in microTari.
        - **payment_id** (bytes): Payment ID associated with the transaction.


        ### Example JavaScript gRPC client usage:
        ```javascript
        const call = client.streamTransactionEvents({});

        call.on("data", (response) => {
        console.log("Transaction Event:", response.transaction);
        });

        call.on("end", () => {
        console.log("Stream ended.");
        });

        call.on("error", (err) => {
        console.error("Stream error:", err);
        });
        ```

        ### Sample JSON Streamed Response:
        ```json
        {
        "transaction": {
        "event": "Mined",
        "tx_id": "103248",
        "source_address": "0xabc123...",
        "dest_address": "0xdef456...",
        "status": "Completed",
        "direction": "Outbound",
        "amount": 100000000,
        "payment_id": "0xdeadbeef..."
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ImportTransactions(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAllCompletedTransactions(self, request, context):
        """Get all completed transactions including cancelled ones, sorted by timestamp and paginated
        DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAllCompletedTransactionsStream(self, request, context):
        """Streams previously completed wallet transactions to the client.

        The `GetAllCompletedTransactionsStream` RPC provides a paginated, filtered stream of previously completed transactions
        from the wallet database. Unlike real-time event streaming, this RPC allows clients to retrieve historical transaction
        data using offset, limit, and optional status-based filtering.

        This is ideal for applications that need to display a transaction history, perform analytics, or resume from a known offset.

        ### Request Parameters:
        - **offset** (uint64): The starting index in the list of completed transactions.
        - **limit** (uint64): Maximum number of transactions to return. Capped at 50 per request.
        - **status_bitflag** (uint64): Optional bitflag to filter transactions by status (e.g., mined, cancelled).

        ### Response Stream:
        - Each message in the response stream is a `GetCompletedTransactionsResponse` containing:
        - **transaction**: A `TransactionInfo` object representing a completed wallet transaction.

        ### `TransactionInfo` Fields:
        - **tx_id** (uint64): Unique transaction identifier.
        - **source_address** (bytes): Sender address.
        - **dest_address** (bytes): Recipient address.
        - **status** (enum): Status of the transaction (`Completed`, `Mined`, `Cancelled`, etc.).
        - **direction** (enum): `"Inbound"` or `"Outbound"`.
        - **amount** (uint64): Transaction amount in microTari.
        - **fee** (uint64): Transaction fee in microTari.
        - **is_cancelled** (bool): Whether the transaction was cancelled.
        - **excess_sig** (bytes): Signature of the transaction kernel excess.
        - **timestamp** (uint64): UNIX timestamp of the transaction creation time.
        - **raw_payment_id** (bytes): Raw payment ID used in the transaction.
        - **user_payment_id** (bytes): User-visible payment ID, if applicable.
        - **mined_in_block_height** (uint64): Block height where the transaction was mined. Zero if not mined.
        - **input_commitments** (repeated bytes): Commitments for transaction inputs.
        - **output_commitments** (repeated bytes): Commitments for transaction outputs.
        - **payment_references_sent** (repeated bytes): Metadata references associated with sent outputs.
        - **payment_references_received** (repeated bytes): Metadata references associated with received outputs.
        - **payment_references_change** (repeated bytes): Metadata references associated with change outputs.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const call = client.getAllCompletedTransactionsStream({
        offset: 0,
        limit: 20,
        status_bitflag: 0
        });

        call.on("data", (response) => {
        console.log("Completed Transaction:", response.transaction);
        });

        call.on("end", () => {
        console.log("Stream ended.");
        });

        call.on("error", (err) => {
        console.error("Stream error:", err);
        });
        ```

        ### Sample JSON Streamed Response:
        ```json
        {
        "transaction": {
        "tx_id": 103248,
        "source_address": "0xabc123...",
        "dest_address": "0xdef456...",
        "status": "Completed",
        "direction": "Outbound",
        "amount": 100000000,
        "fee": 200000,
        "is_cancelled": false,
        "excess_sig": "0x...",
        "timestamp": 1670000000,
        "raw_payment_id": "0xdeadbeef...",
        "user_payment_id": "0xdeadbeef...",
        "mined_in_block_height": 202000,
        "input_commitments": ["0x...", "0x..."],
        "output_commitments": ["0x...", "0x..."],
        "payment_references_sent": ["0x...", "0x..."],
        "payment_references_received": [],
        "payment_references_change": []
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPaymentByReference(self, request, context):
        """Gets transaction information by payment reference (PayRef)

        The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
        PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
        transactions even after outputs are spent.

        ### Request Parameters:

        - `payment_reference` (required):
        - **Type**: `bytes` (32 bytes)
        - **Description**: The payment reference hash to look up
        - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef

        ### Example JavaScript gRPC client usage:

        ```javascript
        const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
        const request = { payment_reference: payref };
        client.getPaymentByReference(request, (err, response) => {
        if (err) console.error(err);
        else console.log('Transaction found:', response.transaction);
        });
        ```

        ### Sample JSON Response:

        ```json
        {
        "transaction": {
        "tx_id": 12345,
        "source_address": "0x1234abcd...",
        "dest_address": "0x5678efgh...",
        "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        "direction": "TRANSACTION_DIRECTION_INBOUND",
        "amount": 1000000,
        "fee": 20,
        "is_cancelled": false,
        "excess_sig": "0xabcdef...",
        "timestamp": 1681234567,
        "payment_id": "0xdeadbeef...",
        "mined_in_block_height": 150000
        }
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetFeeEstimate(self, request, context):
        """Estimates the transaction fee based on amount, fee rate, and number of outputs.

        The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
        This is useful for presenting fee information to the user or for ensuring sufficient funds are available.

        ### Request Parameters:
        - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 ÂµT).
        - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
        - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).

        ### Input Validation:
        - `amount` must be a non-zero `uint64` representing the amount to transfer.
        - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
        - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.

        ### Response Fields:
        - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        amount: 1000000,         // Sending 1 Tari
        fee_per_gram: 5,         // Fee rate of 5 ÂµT/g
        output_count: 2          // One recipient + one change output
        };
        client.getFeeEstimate(request, (err, response) => {
        if (err) console.error(err);
        else console.log("Estimated fee:", response.estimated_fee);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "estimated_fee": 12345
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetFeePerGramStats(self, request, context):
        """Retrieves fee-per-gram statistics over recent blocks.

        The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
        understand recent network fee trends. This can be used for setting appropriate fees
        when constructing transactions.

        ### Request Parameters:
        - **block_count** (optional): The number of recent blocks to include in the statistics.
        If not specified or zero, a default number of blocks will be used.

        ### Input Validation:
        - `block_count` must be a non-negative `uint64`. Large values may increase query time.

        ### Response Fields:
        - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.

        Each `FeePerGramStat` contains:
        - **average_fee_per_gram**: Average fee per gram observed over the blocks.
        - **min_fee_per_gram**: Minimum fee per gram observed.
        - **max_fee_per_gram**: Maximum fee per gram observed.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        block_count: 10 // Consider fees over the last 10 blocks
        };
        client.getFeePerGramStats(request, (err, response) => {
        if (err) console.error(err);
        else response.fee_per_gram_stats.forEach(stat => {
        console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
        });
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "fee_per_gram_stats": [
        {
        "average_fee_per_gram": 5,
        "min_fee_per_gram": 3,
        "max_fee_per_gram": 10
        }
        ]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReplaceByFee(self, request, context):
        """Attempts to replace an existing transaction with a new one that has a higher fee.

        The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
        potentially speeding up its confirmation by incentivizing miners to prioritize it.

        ### Request Parameters:
        - **transaction_id** (required): The ID of the original transaction to replace.
        - **fee_increase** (required): The additional fee amount to add, specified in microTari.
        Must be greater than zero.

        ### Input Validation:
        - `transaction_id` must correspond to a currently unconfirmed transaction.
        - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.

        ### Response Fields:
        - **transaction_id**: The transaction ID of the new replacement transaction.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        transaction_id: 123456,
        fee_increase: 5000  // Increase fee by 5,000 microTari
        };
        client.replaceByFee(request, (err, response) => {
        if (err) console.error("Failed to replace by fee:", err);
        else console.log("Replacement transaction ID:", response.transaction_id);
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "transaction_id": 7891011
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def UserPayForFee(self, request, context):
        """Allows users to pay a specified fee for spending transaction outputs to given recipients.

        The `UserPayForFee` call enables clients to request that the wallet pays the fee
        for one or more transactions identified by their IDs, sending funds to the specified recipients.
        This is useful for fee bumping or covering transaction fees on behalf of recipients.

        ### Request Parameters:
        - **recipients** (required): A list of transfers, each specifying:
        - `tx_id`: The transaction ID whose outputs will be spent.
        - `fee`: The fee amount in microTari to pay for this transfer.
        - `destination`: The Base58-encoded Tari address of the recipient.

        ### Input Validation:
        - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
        - Each `fee` must be a non-negative uint64 specifying the fee to pay.
        - Each `destination` must be a valid Base58 Tari address.

        ### Response Fields:
        - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
        - `address`: The recipient address as a string.
        - `transaction_id`: The ID of the newly created transaction (or zero if failed).
        - `is_success`: Boolean indicating if the fee payment transaction succeeded.
        - `failure_message`: A string describing the error if the transaction failed.
        - `transaction_info`: Detailed transaction metadata if available.

        ### Example JavaScript gRPC client usage:
        ```javascript
        const request = {
        recipients: [
        {
        tx_id: 123,
        fee: 1000,
        destination: "tari1qxyz..."
        },
        {
        tx_id: 456,
        fee: 2000,
        destination: "tari1qabcd..."
        }
        ]
        };
        client.userPayForFee(request, (err, response) => {
        if (err) console.error("Fee payment failed:", err);
        else {
        response.results.forEach(result => {
        if (result.is_success) {
        console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
        } else {
        console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
        }
        });
        }
        });
        ```

        ### Sample JSON Response:
        ```json
        {
        "results": [
        {
        "address": "tari1qxyz...",
        "transaction_id": 789,
        "is_success": true,
        "failure_message": "",
        "transaction_info": {
        "tx_id": 789,
        "source_address": "...",
        "dest_address": "...",
        "status": "Completed",
        "direction": "Outbound",
        "amount": 50000,
        "fee": 1000,
        "is_cancelled": false,
        "timestamp": 1620000000
        }
        },
        {
        "address": "tari1qabcd...",
        "transaction_id": 0,
        "is_success": false,
        "failure_message": "Invalid destination address",
        "transaction_info": null
        }
        ]
        }
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RegisterValidatorNode(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SubmitValidatorEvictionProof(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SubmitValidatorNodeExit(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetBurnClaimProof(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RescanWallet(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ScanAndImportUtxos(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_WalletServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GetVersion': grpc.unary_unary_rpc_method_handler(
                    servicer.GetVersion,
                    request_deserializer=wallet__pb2.GetVersionRequest.FromString,
                    response_serializer=wallet__pb2.GetVersionResponse.SerializeToString,
            ),
            'GetState': grpc.unary_unary_rpc_method_handler(
                    servicer.GetState,
                    request_deserializer=wallet__pb2.GetStateRequest.FromString,
                    response_serializer=wallet__pb2.GetStateResponse.SerializeToString,
            ),
            'CheckConnectivity': grpc.unary_unary_rpc_method_handler(
                    servicer.CheckConnectivity,
                    request_deserializer=wallet__pb2.GetConnectivityRequest.FromString,
                    response_serializer=wallet__pb2.CheckConnectivityResponse.SerializeToString,
            ),
            'CheckForUpdates': grpc.unary_unary_rpc_method_handler(
                    servicer.CheckForUpdates,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=network__pb2.SoftwareUpdate.SerializeToString,
            ),
            'Identify': grpc.unary_unary_rpc_method_handler(
                    servicer.Identify,
                    request_deserializer=network__pb2.GetIdentityRequest.FromString,
                    response_serializer=network__pb2.GetIdentityResponse.SerializeToString,
            ),
            'GetAddress': grpc.unary_unary_rpc_method_handler(
                    servicer.GetAddress,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=wallet__pb2.GetAddressResponse.SerializeToString,
            ),
            'GetPaymentIdAddress': grpc.unary_unary_rpc_method_handler(
                    servicer.GetPaymentIdAddress,
                    request_deserializer=wallet__pb2.GetPaymentIdAddressRequest.FromString,
                    response_serializer=wallet__pb2.GetCompleteAddressResponse.SerializeToString,
            ),
            'GetCompleteAddress': grpc.unary_unary_rpc_method_handler(
                    servicer.GetCompleteAddress,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=wallet__pb2.GetCompleteAddressResponse.SerializeToString,
            ),
            'PrepareOneSidedTransactionForSigning': grpc.unary_unary_rpc_method_handler(
                    servicer.PrepareOneSidedTransactionForSigning,
                    request_deserializer=wallet__pb2.PrepareOneSidedTransactionForSigningRequest.FromString,
                    response_serializer=wallet__pb2.PrepareOneSidedTransactionForSigningResponse.SerializeToString,
            ),
            'PrepareDepositMultisigTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.PrepareDepositMultisigTransaction,
                    request_deserializer=wallet__pb2.PrepareDepositMultisigTransactionRequest.FromString,
                    response_serializer=wallet__pb2.PrepareDepositMultisigTransactionResponse.SerializeToString,
            ),
            'PrepareWithdrawMultisigTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.PrepareWithdrawMultisigTransaction,
                    request_deserializer=wallet__pb2.PrepareWithdrawMultisigTransactionRequest.FromString,
                    response_serializer=wallet__pb2.PrepareWithdrawMultisigTransactionResponse.SerializeToString,
            ),
            'BroadcastSignedOneSidedTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.BroadcastSignedOneSidedTransaction,
                    request_deserializer=wallet__pb2.BroadcastSignedOneSidedTransactionRequest.FromString,
                    response_serializer=wallet__pb2.BroadcastSignedOneSidedTransactionResponse.SerializeToString,
            ),
            'Transfer': grpc.unary_unary_rpc_method_handler(
                    servicer.Transfer,
                    request_deserializer=wallet__pb2.TransferRequest.FromString,
                    response_serializer=wallet__pb2.TransferResponse.SerializeToString,
            ),
            'RangeLimitedCoinJoin': grpc.unary_unary_rpc_method_handler(
                    servicer.RangeLimitedCoinJoin,
                    request_deserializer=wallet__pb2.RangeLimitedCoinJoinRequest.FromString,
                    response_serializer=wallet__pb2.TransferResponse.SerializeToString,
            ),
            'GetTransactionInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.GetTransactionInfo,
                    request_deserializer=wallet__pb2.GetTransactionInfoRequest.FromString,
                    response_serializer=wallet__pb2.GetTransactionInfoResponse.SerializeToString,
            ),
            'GetCompletedTransactions': grpc.unary_stream_rpc_method_handler(
                    servicer.GetCompletedTransactions,
                    request_deserializer=wallet__pb2.GetCompletedTransactionsRequest.FromString,
                    response_serializer=wallet__pb2.GetCompletedTransactionsResponse.SerializeToString,
            ),
            'GetBlockHeightTransactions': grpc.unary_unary_rpc_method_handler(
                    servicer.GetBlockHeightTransactions,
                    request_deserializer=wallet__pb2.GetBlockHeightTransactionsRequest.FromString,
                    response_serializer=wallet__pb2.GetBlockHeightTransactionsResponse.SerializeToString,
            ),
            'GetTransactionPayRefs': grpc.unary_unary_rpc_method_handler(
                    servicer.GetTransactionPayRefs,
                    request_deserializer=wallet__pb2.GetTransactionPayRefsRequest.FromString,
                    response_serializer=wallet__pb2.GetTransactionPayRefsResponse.SerializeToString,
            ),
            'GetBalance': grpc.unary_unary_rpc_method_handler(
                    servicer.GetBalance,
                    request_deserializer=wallet__pb2.GetBalanceRequest.FromString,
                    response_serializer=wallet__pb2.GetBalanceResponse.SerializeToString,
            ),
            'GetUnspentAmounts': grpc.unary_unary_rpc_method_handler(
                    servicer.GetUnspentAmounts,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=wallet__pb2.GetUnspentAmountsResponse.SerializeToString,
            ),
            'CoinSplit': grpc.unary_unary_rpc_method_handler(
                    servicer.CoinSplit,
                    request_deserializer=wallet__pb2.CoinSplitRequest.FromString,
                    response_serializer=wallet__pb2.CoinSplitResponse.SerializeToString,
            ),
            'CoinHistogram': grpc.unary_unary_rpc_method_handler(
                    servicer.CoinHistogram,
                    request_deserializer=wallet__pb2.CoinHistogramRequest.FromString,
                    response_serializer=wallet__pb2.CoinHistogramResponse.SerializeToString,
            ),
            'ImportUtxos': grpc.unary_unary_rpc_method_handler(
                    servicer.ImportUtxos,
                    request_deserializer=wallet__pb2.ImportUtxosRequest.FromString,
                    response_serializer=wallet__pb2.ImportUtxosResponse.SerializeToString,
            ),
            'GetNetworkStatus': grpc.unary_unary_rpc_method_handler(
                    servicer.GetNetworkStatus,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=network__pb2.NetworkStatusResponse.SerializeToString,
            ),
            'GetConnectedHttpPeer': grpc.unary_unary_rpc_method_handler(
                    servicer.GetConnectedHttpPeer,
                    request_deserializer=types__pb2.Empty.FromString,
                    response_serializer=wallet__pb2.GetConnectedHttpPeerResponse.SerializeToString,
            ),
            'CancelTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.CancelTransaction,
                    request_deserializer=wallet__pb2.CancelTransactionRequest.FromString,
                    response_serializer=wallet__pb2.CancelTransactionResponse.SerializeToString,
            ),
            'RevalidateAllTransactions': grpc.unary_unary_rpc_method_handler(
                    servicer.RevalidateAllTransactions,
                    request_deserializer=wallet__pb2.RevalidateRequest.FromString,
                    response_serializer=wallet__pb2.RevalidateResponse.SerializeToString,
            ),
            'ValidateAllTransactions': grpc.unary_unary_rpc_method_handler(
                    servicer.ValidateAllTransactions,
                    request_deserializer=wallet__pb2.ValidateRequest.FromString,
                    response_serializer=wallet__pb2.ValidateResponse.SerializeToString,
            ),
            'SendShaAtomicSwapTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.SendShaAtomicSwapTransaction,
                    request_deserializer=wallet__pb2.SendShaAtomicSwapRequest.FromString,
                    response_serializer=wallet__pb2.SendShaAtomicSwapResponse.SerializeToString,
            ),
            'CreateBurnTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.CreateBurnTransaction,
                    request_deserializer=wallet__pb2.CreateBurnTransactionRequest.FromString,
                    response_serializer=wallet__pb2.CreateBurnTransactionResponse.SerializeToString,
            ),
            'ClaimShaAtomicSwapTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.ClaimShaAtomicSwapTransaction,
                    request_deserializer=wallet__pb2.ClaimShaAtomicSwapRequest.FromString,
                    response_serializer=wallet__pb2.ClaimShaAtomicSwapResponse.SerializeToString,
            ),
            'ClaimHtlcRefundTransaction': grpc.unary_unary_rpc_method_handler(
                    servicer.ClaimHtlcRefundTransaction,
                    request_deserializer=wallet__pb2.ClaimHtlcRefundRequest.FromString,
                    response_serializer=wallet__pb2.ClaimHtlcRefundResponse.SerializeToString,
            ),
            'CreateTemplateRegistration': grpc.unary_unary_rpc_method_handler(
                    servicer.CreateTemplateRegistration,
                    request_deserializer=wallet__pb2.CreateTemplateRegistrationRequest.FromString,
                    response_serializer=wallet__pb2.CreateTemplateRegistrationResponse.SerializeToString,
            ),
            'SignMessage': grpc.unary_unary_rpc_method_handler(
                    servicer.SignMessage,
                    request_deserializer=wallet__pb2.SignMessageRequest.FromString,
                    response_serializer=wallet__pb2.SignMessageResponse.SerializeToString,
            ),
            'StreamTransactionEvents': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamTransactionEvents,
                    request_deserializer=wallet__pb2.TransactionEventRequest.FromString,
                    response_serializer=wallet__pb2.TransactionEventResponse.SerializeToString,
            ),
            'ImportTransactions': grpc.unary_unary_rpc_method_handler(
                    servicer.ImportTransactions,
                    request_deserializer=wallet__pb2.ImportTransactionsRequest.FromString,
                    response_serializer=wallet__pb2.ImportTransactionsResponse.SerializeToString,
            ),
            'GetAllCompletedTransactions': grpc.unary_unary_rpc_method_handler(
                    servicer.GetAllCompletedTransactions,
                    request_deserializer=wallet__pb2.GetAllCompletedTransactionsRequest.FromString,
                    response_serializer=wallet__pb2.GetAllCompletedTransactionsResponse.SerializeToString,
            ),
            'GetAllCompletedTransactionsStream': grpc.unary_stream_rpc_method_handler(
                    servicer.GetAllCompletedTransactionsStream,
                    request_deserializer=wallet__pb2.GetAllCompletedTransactionsRequest.FromString,
                    response_serializer=wallet__pb2.GetCompletedTransactionsResponse.SerializeToString,
            ),
            'GetPaymentByReference': grpc.unary_unary_rpc_method_handler(
                    servicer.GetPaymentByReference,
                    request_deserializer=wallet__pb2.GetPaymentByReferenceRequest.FromString,
                    response_serializer=wallet__pb2.GetPaymentByReferenceResponse.SerializeToString,
            ),
            'GetFeeEstimate': grpc.unary_unary_rpc_method_handler(
                    servicer.GetFeeEstimate,
                    request_deserializer=wallet__pb2.GetFeeEstimateRequest.FromString,
                    response_serializer=wallet__pb2.GetFeeEstimateResponse.SerializeToString,
            ),
            'GetFeePerGramStats': grpc.unary_unary_rpc_method_handler(
                    servicer.GetFeePerGramStats,
                    request_deserializer=wallet__pb2.GetFeePerGramStatsRequest.FromString,
                    response_serializer=wallet__pb2.GetFeePerGramStatsResponse.SerializeToString,
            ),
            'ReplaceByFee': grpc.unary_unary_rpc_method_handler(
                    servicer.ReplaceByFee,
                    request_deserializer=wallet__pb2.ReplaceByFeeRequest.FromString,
                    response_serializer=wallet__pb2.ReplaceByFeeResponse.SerializeToString,
            ),
            'UserPayForFee': grpc.unary_unary_rpc_method_handler(
                    servicer.UserPayForFee,
                    request_deserializer=wallet__pb2.UserPayForFeeRequest.FromString,
                    response_serializer=wallet__pb2.UserPayForFeeResponse.SerializeToString,
            ),
            'RegisterValidatorNode': grpc.unary_unary_rpc_method_handler(
                    servicer.RegisterValidatorNode,
                    request_deserializer=wallet__pb2.RegisterValidatorNodeRequest.FromString,
                    response_serializer=wallet__pb2.RegisterValidatorNodeResponse.SerializeToString,
            ),
            'SubmitValidatorEvictionProof': grpc.unary_unary_rpc_method_handler(
                    servicer.SubmitValidatorEvictionProof,
                    request_deserializer=wallet__pb2.SubmitValidatorEvictionProofRequest.FromString,
                    response_serializer=wallet__pb2.SubmitValidatorEvictionProofResponse.SerializeToString,
            ),
            'SubmitValidatorNodeExit': grpc.unary_unary_rpc_method_handler(
                    servicer.SubmitValidatorNodeExit,
                    request_deserializer=wallet__pb2.SubmitValidatorNodeExitRequest.FromString,
                    response_serializer=wallet__pb2.SubmitValidatorNodeExitResponse.SerializeToString,
            ),
            'GetBurnClaimProof': grpc.unary_unary_rpc_method_handler(
                    servicer.GetBurnClaimProof,
                    request_deserializer=wallet__pb2.GetBurnClaimProofRequest.FromString,
                    response_serializer=wallet__pb2.GetBurnClaimProofResponse.SerializeToString,
            ),
            'RescanWallet': grpc.unary_unary_rpc_method_handler(
                    servicer.RescanWallet,
                    request_deserializer=wallet__pb2.RescanWalletRequest.FromString,
                    response_serializer=wallet__pb2.RescanWalletResponse.SerializeToString,
            ),
            'ScanAndImportUtxos': grpc.unary_unary_rpc_method_handler(
                    servicer.ScanAndImportUtxos,
                    request_deserializer=wallet__pb2.ScanAndImportUtxosRequest.FromString,
                    response_serializer=wallet__pb2.ScanAndImportUtxosResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'tari.rpc.Wallet', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('tari.rpc.Wallet', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Wallet(object):
    """The gRPC interface for interacting with the wallet.
    Returns the current version of the running wallet service.

    This method retrieves the semantic version of the wallet software as defined in the Cargo.toml file (e.g., "1.2.3"). Useful for diagnostics and compatibility checks.

    Example usage (JavaScript gRPC client):
    ```javascript
    const response = await client.getVersion({});
    console.log(response.version); // e.g., "1.2.3"
    ```

    Example response:
    ```json
    {
    "version": "1.2.3"
    }
    ```
    """

    @staticmethod
    def GetVersion(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetVersion',
            wallet__pb2.GetVersionRequest.SerializeToString,
            wallet__pb2.GetVersionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetState(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetState',
            wallet__pb2.GetStateRequest.SerializeToString,
            wallet__pb2.GetStateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CheckConnectivity(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CheckConnectivity',
            wallet__pb2.GetConnectivityRequest.SerializeToString,
            wallet__pb2.CheckConnectivityResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CheckForUpdates(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CheckForUpdates',
            types__pb2.Empty.SerializeToString,
            network__pb2.SoftwareUpdate.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Identify(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/Identify',
            network__pb2.GetIdentityRequest.SerializeToString,
            network__pb2.GetIdentityResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetAddress(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetAddress',
            types__pb2.Empty.SerializeToString,
            wallet__pb2.GetAddressResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetPaymentIdAddress(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetPaymentIdAddress',
            wallet__pb2.GetPaymentIdAddressRequest.SerializeToString,
            wallet__pb2.GetCompleteAddressResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetCompleteAddress(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetCompleteAddress',
            types__pb2.Empty.SerializeToString,
            wallet__pb2.GetCompleteAddressResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PrepareOneSidedTransactionForSigning(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/PrepareOneSidedTransactionForSigning',
            wallet__pb2.PrepareOneSidedTransactionForSigningRequest.SerializeToString,
            wallet__pb2.PrepareOneSidedTransactionForSigningResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PrepareDepositMultisigTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/PrepareDepositMultisigTransaction',
            wallet__pb2.PrepareDepositMultisigTransactionRequest.SerializeToString,
            wallet__pb2.PrepareDepositMultisigTransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PrepareWithdrawMultisigTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/PrepareWithdrawMultisigTransaction',
            wallet__pb2.PrepareWithdrawMultisigTransactionRequest.SerializeToString,
            wallet__pb2.PrepareWithdrawMultisigTransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def BroadcastSignedOneSidedTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/BroadcastSignedOneSidedTransaction',
            wallet__pb2.BroadcastSignedOneSidedTransactionRequest.SerializeToString,
            wallet__pb2.BroadcastSignedOneSidedTransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Transfer(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/Transfer',
            wallet__pb2.TransferRequest.SerializeToString,
            wallet__pb2.TransferResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RangeLimitedCoinJoin(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/RangeLimitedCoinJoin',
            wallet__pb2.RangeLimitedCoinJoinRequest.SerializeToString,
            wallet__pb2.TransferResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetTransactionInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetTransactionInfo',
            wallet__pb2.GetTransactionInfoRequest.SerializeToString,
            wallet__pb2.GetTransactionInfoResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetCompletedTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/tari.rpc.Wallet/GetCompletedTransactions',
            wallet__pb2.GetCompletedTransactionsRequest.SerializeToString,
            wallet__pb2.GetCompletedTransactionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetBlockHeightTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetBlockHeightTransactions',
            wallet__pb2.GetBlockHeightTransactionsRequest.SerializeToString,
            wallet__pb2.GetBlockHeightTransactionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetTransactionPayRefs(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetTransactionPayRefs',
            wallet__pb2.GetTransactionPayRefsRequest.SerializeToString,
            wallet__pb2.GetTransactionPayRefsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetBalance(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetBalance',
            wallet__pb2.GetBalanceRequest.SerializeToString,
            wallet__pb2.GetBalanceResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetUnspentAmounts(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetUnspentAmounts',
            types__pb2.Empty.SerializeToString,
            wallet__pb2.GetUnspentAmountsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CoinSplit(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CoinSplit',
            wallet__pb2.CoinSplitRequest.SerializeToString,
            wallet__pb2.CoinSplitResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CoinHistogram(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CoinHistogram',
            wallet__pb2.CoinHistogramRequest.SerializeToString,
            wallet__pb2.CoinHistogramResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ImportUtxos(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ImportUtxos',
            wallet__pb2.ImportUtxosRequest.SerializeToString,
            wallet__pb2.ImportUtxosResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetNetworkStatus(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetNetworkStatus',
            types__pb2.Empty.SerializeToString,
            network__pb2.NetworkStatusResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetConnectedHttpPeer(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetConnectedHttpPeer',
            types__pb2.Empty.SerializeToString,
            wallet__pb2.GetConnectedHttpPeerResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CancelTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CancelTransaction',
            wallet__pb2.CancelTransactionRequest.SerializeToString,
            wallet__pb2.CancelTransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RevalidateAllTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/RevalidateAllTransactions',
            wallet__pb2.RevalidateRequest.SerializeToString,
            wallet__pb2.RevalidateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ValidateAllTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ValidateAllTransactions',
            wallet__pb2.ValidateRequest.SerializeToString,
            wallet__pb2.ValidateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SendShaAtomicSwapTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/SendShaAtomicSwapTransaction',
            wallet__pb2.SendShaAtomicSwapRequest.SerializeToString,
            wallet__pb2.SendShaAtomicSwapResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CreateBurnTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CreateBurnTransaction',
            wallet__pb2.CreateBurnTransactionRequest.SerializeToString,
            wallet__pb2.CreateBurnTransactionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ClaimShaAtomicSwapTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction',
            wallet__pb2.ClaimShaAtomicSwapRequest.SerializeToString,
            wallet__pb2.ClaimShaAtomicSwapResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ClaimHtlcRefundTransaction(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ClaimHtlcRefundTransaction',
            wallet__pb2.ClaimHtlcRefundRequest.SerializeToString,
            wallet__pb2.ClaimHtlcRefundResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CreateTemplateRegistration(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/CreateTemplateRegistration',
            wallet__pb2.CreateTemplateRegistrationRequest.SerializeToString,
            wallet__pb2.CreateTemplateRegistrationResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SignMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/SignMessage',
            wallet__pb2.SignMessageRequest.SerializeToString,
            wallet__pb2.SignMessageResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StreamTransactionEvents(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/tari.rpc.Wallet/StreamTransactionEvents',
            wallet__pb2.TransactionEventRequest.SerializeToString,
            wallet__pb2.TransactionEventResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ImportTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ImportTransactions',
            wallet__pb2.ImportTransactionsRequest.SerializeToString,
            wallet__pb2.ImportTransactionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetAllCompletedTransactions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetAllCompletedTransactions',
            wallet__pb2.GetAllCompletedTransactionsRequest.SerializeToString,
            wallet__pb2.GetAllCompletedTransactionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetAllCompletedTransactionsStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/tari.rpc.Wallet/GetAllCompletedTransactionsStream',
            wallet__pb2.GetAllCompletedTransactionsRequest.SerializeToString,
            wallet__pb2.GetCompletedTransactionsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetPaymentByReference(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetPaymentByReference',
            wallet__pb2.GetPaymentByReferenceRequest.SerializeToString,
            wallet__pb2.GetPaymentByReferenceResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetFeeEstimate(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetFeeEstimate',
            wallet__pb2.GetFeeEstimateRequest.SerializeToString,
            wallet__pb2.GetFeeEstimateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetFeePerGramStats(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetFeePerGramStats',
            wallet__pb2.GetFeePerGramStatsRequest.SerializeToString,
            wallet__pb2.GetFeePerGramStatsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReplaceByFee(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ReplaceByFee',
            wallet__pb2.ReplaceByFeeRequest.SerializeToString,
            wallet__pb2.ReplaceByFeeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def UserPayForFee(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/UserPayForFee',
            wallet__pb2.UserPayForFeeRequest.SerializeToString,
            wallet__pb2.UserPayForFeeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RegisterValidatorNode(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/RegisterValidatorNode',
            wallet__pb2.RegisterValidatorNodeRequest.SerializeToString,
            wallet__pb2.RegisterValidatorNodeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SubmitValidatorEvictionProof(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/SubmitValidatorEvictionProof',
            wallet__pb2.SubmitValidatorEvictionProofRequest.SerializeToString,
            wallet__pb2.SubmitValidatorEvictionProofResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SubmitValidatorNodeExit(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/SubmitValidatorNodeExit',
            wallet__pb2.SubmitValidatorNodeExitRequest.SerializeToString,
            wallet__pb2.SubmitValidatorNodeExitResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetBurnClaimProof(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/GetBurnClaimProof',
            wallet__pb2.GetBurnClaimProofRequest.SerializeToString,
            wallet__pb2.GetBurnClaimProofResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RescanWallet(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/RescanWallet',
            wallet__pb2.RescanWalletRequest.SerializeToString,
            wallet__pb2.RescanWalletResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ScanAndImportUtxos(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/tari.rpc.Wallet/ScanAndImportUtxos',
            wallet__pb2.ScanAndImportUtxosRequest.SerializeToString,
            wallet__pb2.ScanAndImportUtxosResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
